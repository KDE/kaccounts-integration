diff --git a/configure.ac b/configure.ac
index 7cd8434..80ff1e4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -22,6 +22,10 @@ AC_HEADER_STDC
 AC_CHECK_HEADERS([sys/stat.h sys/types.h sysexits.h])
 AC_CHECK_FUNCS([umask])
 
+LIBACCOUNTS_REQUIRED=1.4
+LIBSIGNON_REQUIRED=1.1
+MC_PLUGINS_REQUIRED=5.13.1
+
 case "$PACKAGE_VERSION" in
   *+)
     mc_is_release=no
@@ -207,51 +211,52 @@ else
   AC_DEFINE([ENABLE_GNOME_KEYRING], [0], [Define whether gnome-keyring support is enabled])
 fi
 
-dnl libaccounts-glib SSO
-libaccounts_sso_enabled="no"
-AC_MSG_CHECKING(whether to build with libaccounts-glib SSO suport)
-
-AC_ARG_ENABLE([libaccounts-sso],
-              AC_HELP_STRING([--enable-libaccounts-sso],
-                             [build with SSO suport. default=no]),
-              [ AC_MSG_RESULT(${enableval})
-                libaccounts_sso_enabled="${enableval}" ],
-              [ AC_MSG_RESULT(no) ] )
-
-AS_IF([ test "x$libaccounts_sso_enabled" = xauto ],
-      [ PKG_CHECK_EXISTS([libaccounts-glib],
-                         [libaccounts_sso_enabled=yes],
-                         [libaccounts_sso_enabled=no]) ])
-
-dnl set up the shell/make variable, the #define and check the package version
-AS_IF([ test "x$libaccounts_sso_enabled" = xyes ],
-      [ ENABLE_LIBACCOUNTS_SSO=yes
-        AC_DEFINE(ENABLE_LIBACCOUNTS_SSO, [1],
-                  [Define if libaccounts SSO support is required])
-        PKG_CHECK_MODULES([LIBACCOUNTS_SSO], [libaccounts-glib >= 0.26]) ],
-      [ AC_DEFINE(ENABLE_LIBACCOUNTS_SSO, [0]) ])
-
-dnl export the CFLAGS and LDFLAGS equivalents determined by PKG_CHECK_MODULES
-AC_SUBST(LIBACCOUNTS_SSO_CFLAGS)
-AC_SUBST(LIBACCOUNTS_SSO_LIBS)
-
-dnl the automake conditional
-AM_CONDITIONAL(ENABLE_LIBACCOUNTS_SSO, [test x$libaccounts_sso_enabled = xyes])
-dnl /libaccounts-glib SSO
-
-AC_ARG_WITH([accounts-glib-hidden-service-type],
-    [AS_HELP_STRING([--with-accounts-glib-hidden-service-type],
-      [mark accounts with the provided service type as hidden @<:@default=no@:>@])],
-    [],
-    [with_accounts_glib_hidden_service_type=no])
-AS_IF([ test "x$with_accounts_glib_hidden_service_type" != xno ],
-    [AC_DEFINE_UNQUOTED(ACCOUNTS_GLIB_HIDDEN_SERVICE_TYPE,
-        ["$with_accounts_glib_hidden_service_type"],
-        [Defined to the non-IM service type for hidden accounts, if any])])
-
-AM_CONDITIONAL(ENABLE_LIBACCOUNTS_GLIB_HIDDEN,
-    [test x$with_accounts_glib_hidden_service_type != xno])
-
+# ----------------------------------------------------------------
+# dnl libaccounts-glib SSO
+# libaccounts_sso_enabled="no"
+# AC_MSG_CHECKING(whether to build with libaccounts-glib SSO suport)
+#
+# AC_ARG_ENABLE([libaccounts-sso],
+#               AC_HELP_STRING([--enable-libaccounts-sso],
+#                              [build with SSO suport. default=no]),
+#               [ AC_MSG_RESULT(${enableval})
+#                 libaccounts_sso_enabled="${enableval}" ],
+#               [ AC_MSG_RESULT(no) ] )
+#
+# AS_IF([ test "x$libaccounts_sso_enabled" = xauto ],
+#       [ PKG_CHECK_EXISTS([libaccounts-glib],
+#                          [libaccounts_sso_enabled=yes],
+#                          [libaccounts_sso_enabled=no]) ])
+#
+# dnl set up the shell/make variable, the #define and check the package version
+# AS_IF([ test "x$libaccounts_sso_enabled" = xyes ],
+#       [ ENABLE_LIBACCOUNTS_SSO=yes
+#         AC_DEFINE(ENABLE_LIBACCOUNTS_SSO, [1],
+#                   [Define if libaccounts SSO support is required])
+#         PKG_CHECK_MODULES([LIBACCOUNTS_SSO], [libaccounts-glib >= 0.26]) ],
+#       [ AC_DEFINE(ENABLE_LIBACCOUNTS_SSO, [0]) ])
+#
+# dnl export the CFLAGS and LDFLAGS equivalents determined by PKG_CHECK_MODULES
+# AC_SUBST(LIBACCOUNTS_SSO_CFLAGS)
+# AC_SUBST(LIBACCOUNTS_SSO_LIBS)
+#
+# dnl the automake conditional
+# AM_CONDITIONAL(ENABLE_LIBACCOUNTS_SSO, [test x$libaccounts_sso_enabled = xyes])
+# dnl /libaccounts-glib SSO
+#
+# AC_ARG_WITH([accounts-glib-hidden-service-type],
+#     [AS_HELP_STRING([--with-accounts-glib-hidden-service-type],
+#       [mark accounts with the provided service type as hidden @<:@default=no@:>@])],
+#     [],
+#     [with_accounts_glib_hidden_service_type=no])
+# AS_IF([ test "x$with_accounts_glib_hidden_service_type" != xno ],
+#     [AC_DEFINE_UNQUOTED(ACCOUNTS_GLIB_HIDDEN_SERVICE_TYPE,
+#         ["$with_accounts_glib_hidden_service_type"],
+#         [Defined to the non-IM service type for hidden accounts, if any])])
+#
+# AM_CONDITIONAL(ENABLE_LIBACCOUNTS_GLIB_HIDDEN,
+#     [test x$with_accounts_glib_hidden_service_type != xno])
+#
 PKG_CHECK_MODULES(DBUS, [dbus-1 >= 0.95, dbus-glib-1 >= 0.82])
 AC_SUBST(DBUS_CFLAGS)
 AC_SUBST(DBUS_LIBS)
@@ -280,6 +285,80 @@ if test x"$HAVE_MCE" = xyes; then
 fi
 
 # -----------------------------------------------------------
+# ubuntu-online-accounts support
+# -----------------------------------------------------------
+AC_ARG_ENABLE(ubuntu-online-accounts,
+              AS_HELP_STRING([--enable-ubuntu-online-accounts=@<:@no/yes/auto@:>@],
+                             [build Ubuntu Online Accounts plugins]), ,
+                             enable_ubuntu_online_accounts=auto)
+
+if test "x$enable_ubuntu_online_accounts" != "xno"; then
+   PKG_CHECK_MODULES(UOA,
+    [
+       libaccounts-glib >= $LIBACCOUNTS_REQUIRED
+       libsignon-glib >= $LIBSIGNON_REQUIRED
+    ], have_uoa="yes", have_uoa="no")
+
+   # provider plugin dir
+#    AC_MSG_CHECKING([Accounts provider plugin dir])
+#    ACCOUNTS_PROVIDER_PLUGIN_DIR=`pkg-config --variable=provider_plugindir account-plugin`
+
+#    AC_MSG_RESULT([$ACCOUNTS_PROVIDER_PLUGIN_DIR])
+#    AC_SUBST(ACCOUNTS_PROVIDER_PLUGIN_DIR)
+
+   # app plugin dir
+#    AC_MSG_CHECKING([Accounts provider app plugin dir])
+#    ACCOUNTS_APP_PLUGIN_DIR=`pkg-config --variable=application_plugindir account-plugin`
+
+#    AC_MSG_RESULT([$ACCOUNTS_APP_PLUGIN_DIR])
+#    AC_SUBST(ACCOUNTS_APP_PLUGIN_DIR)
+
+   # provider files dir
+   AC_MSG_CHECKING([Accounts provider files dir])
+   ACCOUNTS_PROVIDER_FILES_DIR=`pkg-config --variable=providerfilesdir libaccounts-glib`
+
+   AC_MSG_RESULT([$ACCOUNTS_PROVIDER_FILES_DIR])
+   AC_SUBST(ACCOUNTS_PROVIDER_FILES_DIR)
+
+   # service files dir
+   AC_MSG_CHECKING([Accounts service files dir])
+   ACCOUNTS_SERVICE_FILES_DIR=`pkg-config --variable=servicefilesdir libaccounts-glib`
+
+   AC_MSG_RESULT([$ACCOUNTS_SERVICE_FILES_DIR])
+   AC_SUBST(ACCOUNTS_SERVICE_FILES_DIR)
+
+   # application files dir
+   AC_MSG_CHECKING([Accounts applications files dir])
+   ACCOUNTS_APPLICATION_FILES_DIR=`pkg-config --variable=applicationfilesdir libaccounts-glib`
+
+   AC_MSG_RESULT([$ACCOUNTS_APPLICATION_FILES_DIR])
+   AC_SUBST(ACCOUNTS_APPLICATION_FILES_DIR)
+
+else
+   have_uoa=no
+fi
+
+if test "x$enable_ubuntu_online_accounts" = "xyes" -a "x$have_uoa" != "xyes"; then
+   AC_MSG_ERROR([Could not find Ubuntu Online Accounts dependencies:
+
+$UOA_PKG_ERRORS])
+fi
+
+if test "x$have_uoa" = "xyes"; then
+   AC_DEFINE(HAVE_UOA, 1, [Define to 1 to build Ubuntu Online Accounts plugins])
+fi
+
+AM_CONDITIONAL([HAVE_UOA], [test "x$have_uoa" = "xyes"])
+
+# if test "x$have_uoa" = "xyes" -o "x$have_goa" = "xyes"; then
+#    AC_MSG_CHECKING([Mission Control plugins dir])
+#    MISSION_CONTROL_PLUGINS_DIR=${libdir}/mission-control-plugins.`pkg-config --variable=MCP_ABI_VERSION mission-control-plugins`
+#
+#    AC_MSG_RESULT([$MISSION_CONTROL_PLUGINS_DIR])
+#    AC_SUBST(MISSION_CONTROL_PLUGINS_DIR)
+# fi
+
+# -----------------------------------------------------------
 # Connectivity integration
 # -----------------------------------------------------------
 AC_ARG_WITH(connectivity,
@@ -427,7 +506,10 @@ Configure summary:
         Connectivity GSetting........:  ${enable_conn_setting}
         Suspend tracking with UPower.:  ${have_upower}
         Aegis........................:  ${aegis_enabled}
-        libaccounts-glib backend.....:  ${libaccounts_sso_enabled}
+        Accounts SSO.................:  ${have_uoa}
         Hidden accounts-glib accounts:  ${with_accounts_glib_hidden_service_type}
         Nokia Mode Control Entity....:  ${HAVE_MCE}
 "
+
+#         libaccounts-glib backend.....:  ${libaccounts_sso_enabled}
+
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 23ccc6c..a49b691 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -20,3 +20,25 @@ libmcp_aegis_la_LIBADD = \
 	$(AEGIS_LIBS)
 
 endif
+
+AM_CPPFLAGS = \
+        $(UOA_CFLAGS) \
+        $(ERROR_CFLAGS)
+
+pluginsdir = $(libdir)
+plugins_LTLIBRARIES = \
+        mcp-account-manager-uoa.la
+
+mcp_account_manager_uoa_la_SOURCES = \
+        mission-control-plugin.c \
+        mcp-account-manager-uoa.c mcp-account-manager-uoa.h \
+        empathy-webcredentials-monitor.c empathy-webcredentials-monitor.h \
+	$(NULL)
+
+mcp_account_manager_uoa_la_LIBADD = \
+        $(UOA_LIBS)
+
+mcp_account_manager_uoa_la_LDFLAGS = \
+        -module \
+        -avoid-version
+
diff --git a/plugins/empathy-webcredentials-monitor.c b/plugins/empathy-webcredentials-monitor.c
new file mode 100644
index 0000000..439bbda
--- /dev/null
+++ b/plugins/empathy-webcredentials-monitor.c
@@ -0,0 +1,283 @@
+#include "config.h"
+
+#include <gio/gio.h>
+
+#include <telepathy-glib/telepathy-glib.h>
+
+#include <libaccounts-glib/ag-account.h>
+
+#include "empathy-webcredentials-monitor.h"
+
+G_DEFINE_TYPE (EmpathyWebcredentialsMonitor, empathy_webcredentials_monitor, G_TYPE_OBJECT)
+
+#define WEBCRED_BUS_NAME "com.canonical.indicators.webcredentials"
+#define WEBCRED_PATH "/com/canonical/indicators/webcredentials"
+#define WEBCRED_IFACE "com.canonical.indicators.webcredentials"
+
+#define FAILURES_PROP "Failures"
+
+enum
+{
+  PROP_MANAGER = 1,
+  N_PROPS
+};
+
+enum
+{
+  SIG_FAILURE_ADDED,
+  SIG_FAILURE_REMOVED,
+  LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL];
+
+struct _EmpathyWebcredentialsMonitorPriv
+{
+  AgManager *manager;
+  GDBusProxy *proxy;
+
+  /* array of owned AgAccount */
+  GPtrArray *failures;
+};
+
+static void
+empathy_webcredentials_monitor_get_property (GObject *object,
+    guint property_id,
+    GValue *value,
+    GParamSpec *pspec)
+{
+  EmpathyWebcredentialsMonitor *self = EMPATHY_WEBCREDENTIALS_MONITOR (object);
+
+  switch (property_id)
+    {
+      case PROP_MANAGER:
+        g_value_set_object (value, self->priv->manager);
+        break;
+      default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+        break;
+    }
+}
+
+static void
+empathy_webcredentials_monitor_set_property (GObject *object,
+    guint property_id,
+    const GValue *value,
+    GParamSpec *pspec)
+{
+  EmpathyWebcredentialsMonitor *self = EMPATHY_WEBCREDENTIALS_MONITOR (object);
+
+  switch (property_id)
+    {
+      case PROP_MANAGER:
+        g_assert (self->priv->manager == NULL); /* construct only */
+        self->priv->manager = g_value_dup_object (value);
+        break;
+      default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+        break;
+    }
+}
+
+static void
+empathy_webcredentials_monitor_constructed (GObject *object)
+{
+  EmpathyWebcredentialsMonitor *self = EMPATHY_WEBCREDENTIALS_MONITOR (object);
+  void (*chain_up) (GObject *) =
+      ((GObjectClass *) empathy_webcredentials_monitor_parent_class)->constructed;
+
+  chain_up (object);
+
+  g_assert (AG_IS_MANAGER (self->priv->manager));
+}
+
+static void
+empathy_webcredentials_monitor_dispose (GObject *object)
+{
+  EmpathyWebcredentialsMonitor *self = EMPATHY_WEBCREDENTIALS_MONITOR (object);
+  void (*chain_up) (GObject *) =
+      ((GObjectClass *) empathy_webcredentials_monitor_parent_class)->dispose;
+
+  g_clear_object (&self->priv->manager);
+  g_clear_object (&self->priv->proxy);
+
+  chain_up (object);
+}
+
+static void
+empathy_webcredentials_monitor_finalize (GObject *object)
+{
+  EmpathyWebcredentialsMonitor *self = EMPATHY_WEBCREDENTIALS_MONITOR (object);
+  void (*chain_up) (GObject *) =
+      ((GObjectClass *) empathy_webcredentials_monitor_parent_class)->finalize;
+
+  g_ptr_array_unref (self->priv->failures);
+
+  chain_up (object);
+}
+
+static void
+empathy_webcredentials_monitor_class_init (
+    EmpathyWebcredentialsMonitorClass *klass)
+{
+  GObjectClass *oclass = G_OBJECT_CLASS (klass);
+  GParamSpec *spec;
+
+  oclass->get_property = empathy_webcredentials_monitor_get_property;
+  oclass->set_property = empathy_webcredentials_monitor_set_property;
+  oclass->constructed = empathy_webcredentials_monitor_constructed;
+  oclass->dispose = empathy_webcredentials_monitor_dispose;
+  oclass->finalize = empathy_webcredentials_monitor_finalize;
+
+  spec = g_param_spec_object ("manager", "Manager",
+      "AgManager",
+      AG_TYPE_MANAGER,
+      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_STRINGS);
+  g_object_class_install_property (oclass, PROP_MANAGER, spec);
+
+  signals[SIG_FAILURE_ADDED] = g_signal_new ("failure-added",
+      G_OBJECT_CLASS_TYPE (klass),
+      G_SIGNAL_RUN_LAST,
+      0, NULL, NULL, NULL,
+      G_TYPE_NONE,
+      1, AG_TYPE_ACCOUNT);
+
+  signals[SIG_FAILURE_REMOVED] = g_signal_new ("failure-removed",
+      G_OBJECT_CLASS_TYPE (klass),
+      G_SIGNAL_RUN_LAST,
+      0, NULL, NULL, NULL,
+      G_TYPE_NONE,
+      1, AG_TYPE_ACCOUNT);
+
+  g_type_class_add_private (klass, sizeof (EmpathyWebcredentialsMonitorPriv));
+}
+
+static void
+update_failures (EmpathyWebcredentialsMonitor *self)
+{
+  GVariant *failures, *f;
+  GVariantIter iter;
+  GList *new_list = NULL;
+  guint i;
+
+  failures = g_dbus_proxy_get_cached_property (self->priv->proxy,
+      FAILURES_PROP);
+  if (failures == NULL)
+    {
+      g_debug ("Does not implement Failures property");
+      return;
+    }
+
+  g_variant_iter_init (&iter, failures);
+  while ((f = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      guint32 id;
+      AgAccount *account;
+
+      id = g_variant_get_uint32 (f);
+
+      account = ag_manager_get_account (self->priv->manager, id);
+      if (account == NULL)
+        continue;
+
+      /* Pass ownership of 'account' to the list */
+      new_list = g_list_append (new_list, account);
+
+      if (!tp_g_ptr_array_contains (self->priv->failures, account))
+        {
+          g_ptr_array_add (self->priv->failures, g_object_ref (account));
+
+          g_signal_emit (self, signals[SIG_FAILURE_ADDED], 0, account);
+        }
+
+      g_variant_unref (f);
+    }
+
+  g_variant_unref (failures);
+
+  for (i = 0; i < self->priv->failures->len; i++)
+    {
+      AgAccount *account = g_ptr_array_index (self->priv->failures, i);
+
+      if (g_list_find (new_list, account) == NULL)
+        {
+          g_object_ref (account);
+          g_ptr_array_remove (self->priv->failures, account);
+
+          g_signal_emit (self, signals[SIG_FAILURE_REMOVED], 0, account);
+          g_object_unref (account);
+        }
+    }
+
+  g_list_free_full (new_list, g_object_unref);
+}
+
+static void
+properties_changed_cb (GDBusProxy *proxy,
+    GVariant *changed_properties,
+    GStrv invalidated_properties,
+    EmpathyWebcredentialsMonitor *self)
+{
+  if (g_variant_lookup_value (changed_properties, FAILURES_PROP, NULL) == NULL)
+    return;
+
+  update_failures (self);
+}
+
+static void
+proxy_new_cb (GObject *source,
+    GAsyncResult *result,
+    gpointer user_data)
+{
+  EmpathyWebcredentialsMonitor *self;
+  TpWeakRef *wr = user_data;
+  GError *error = NULL;
+
+  self = tp_weak_ref_dup_object (wr);
+  if (self == NULL)
+    goto out;
+
+  self->priv->proxy = g_dbus_proxy_new_for_bus_finish (result, &error);
+  if (self->priv->proxy == NULL)
+    {
+      g_debug ("Failed to create webcredentials proxy: %s", error->message);
+      g_error_free (error);
+      goto out;
+    }
+
+  update_failures (self);
+
+  g_signal_connect (self->priv->proxy, "g-properties-changed",
+      G_CALLBACK (properties_changed_cb), self);
+
+out:
+  tp_weak_ref_destroy (wr);
+  g_clear_object (&self);
+}
+
+static void
+empathy_webcredentials_monitor_init (EmpathyWebcredentialsMonitor *self)
+{
+  self->priv = G_TYPE_INSTANCE_GET_PRIVATE (self,
+      EMPATHY_TYPE_WEBCREDENTIALS_MONITOR, EmpathyWebcredentialsMonitorPriv);
+
+  self->priv->failures = g_ptr_array_new_with_free_func (g_object_unref);
+
+  g_dbus_proxy_new_for_bus (G_BUS_TYPE_SESSION, G_DBUS_PROXY_FLAGS_NONE, NULL,
+      WEBCRED_BUS_NAME, WEBCRED_PATH, WEBCRED_IFACE,
+      NULL, proxy_new_cb, tp_weak_ref_new (self, NULL, NULL));
+}
+
+EmpathyWebcredentialsMonitor *
+empathy_webcredentials_monitor_new (AgManager *manager)
+{
+  return g_object_new (EMPATHY_TYPE_WEBCREDENTIALS_MONITOR,
+      "manager", manager,
+      NULL);
+}
+
+GPtrArray *
+empathy_webcredentials_get_failures (EmpathyWebcredentialsMonitor *self)
+{
+  return self->priv->failures;
+}
diff --git a/plugins/empathy-webcredentials-monitor.h b/plugins/empathy-webcredentials-monitor.h
new file mode 100644
index 0000000..cf373a2
--- /dev/null
+++ b/plugins/empathy-webcredentials-monitor.h
@@ -0,0 +1,59 @@
+#ifndef __EMPATHY_WEBCREDENTIALS_MONITOR_H__
+#define __EMPATHY_WEBCREDENTIALS_MONITOR_H__
+
+#include <glib-object.h>
+
+#include <libaccounts-glib/ag-manager.h>
+
+G_BEGIN_DECLS
+
+typedef struct _EmpathyWebcredentialsMonitor EmpathyWebcredentialsMonitor;
+typedef struct _EmpathyWebcredentialsMonitorClass EmpathyWebcredentialsMonitorClass;
+typedef struct _EmpathyWebcredentialsMonitorPriv EmpathyWebcredentialsMonitorPriv;
+
+struct _EmpathyWebcredentialsMonitorClass
+{
+  /*<private>*/
+  GObjectClass parent_class;
+};
+
+struct _EmpathyWebcredentialsMonitor
+{
+  /*<private>*/
+  GObject parent;
+  EmpathyWebcredentialsMonitorPriv *priv;
+};
+
+GType empathy_webcredentials_monitor_get_type (void);
+
+/* TYPE MACROS */
+#define EMPATHY_TYPE_WEBCREDENTIALS_MONITOR \
+  (empathy_webcredentials_monitor_get_type ())
+#define EMPATHY_WEBCREDENTIALS_MONITOR(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj), \
+    EMPATHY_TYPE_WEBCREDENTIALS_MONITOR, \
+    EmpathyWebcredentialsMonitor))
+#define EMPATHY_WEBCREDENTIALS_MONITOR_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass), \
+    EMPATHY_TYPE_WEBCREDENTIALS_MONITOR, \
+    EmpathyWebcredentialsMonitorClass))
+#define EMPATHY_IS_WEBCREDENTIALS_MONITOR(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj), \
+    EMPATHY_TYPE_WEBCREDENTIALS_MONITOR))
+#define EMPATHY_IS_WEBCREDENTIALS_MONITOR_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass), \
+    EMPATHY_TYPE_WEBCREDENTIALS_MONITOR))
+#define EMPATHY_WEBCREDENTIALS_MONITOR_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS ((obj), \
+    EMPATHY_TYPE_WEBCREDENTIALS_MONITOR, \
+    EmpathyWebcredentialsMonitorClass))
+
+EmpathyWebcredentialsMonitor * empathy_webcredentials_monitor_new (
+    AgManager *manager);
+
+GPtrArray * empathy_webcredentials_get_failures (
+    EmpathyWebcredentialsMonitor *self);
+
+G_END_DECLS
+
+#endif /* #ifndef __EMPATHY_WEBCREDENTIALS_MONITOR_H__*/
diff --git a/plugins/mcp-account-manager-uoa.c b/plugins/mcp-account-manager-uoa.c
new file mode 100644
index 0000000..775125a
--- /dev/null
+++ b/plugins/mcp-account-manager-uoa.c
@@ -0,0 +1,826 @@
+/*
+ * Copyright © 2012 Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "config.h"
+#include "mcp-account-manager-uoa.h"
+
+#include <telepathy-glib/telepathy-glib.h>
+
+#include <libaccounts-glib/ag-account.h>
+#include <libaccounts-glib/ag-account-service.h>
+#include <libaccounts-glib/ag-manager.h>
+#include <libaccounts-glib/ag-service.h>
+
+#include <string.h>
+#include <ctype.h>
+
+#include "empathy-webcredentials-monitor.h"
+
+#define PLUGIN_NAME "uoa"
+#define PLUGIN_PRIORITY (MCP_ACCOUNT_STORAGE_PLUGIN_PRIO_KEYRING + 10)
+#define PLUGIN_DESCRIPTION "Provide Telepathy Accounts from UOA via libaccounts-glib"
+#define PLUGIN_PROVIDER EMPATHY_UOA_PROVIDER
+
+#define DEBUG g_debug
+
+#define SERVICE_TYPE "IM"
+#define KEY_PREFIX "telepathy/"
+#define KEY_ACCOUNT_NAME "mc-account-name"
+#define KEY_READONLY_PARAMS "mc-readonly-params"
+
+static void account_storage_iface_init (McpAccountStorageIface *iface);
+
+G_DEFINE_TYPE_WITH_CODE (McpAccountManagerUoa, mcp_account_manager_uoa,
+    G_TYPE_OBJECT,
+    G_IMPLEMENT_INTERFACE (MCP_TYPE_ACCOUNT_STORAGE,
+        account_storage_iface_init));
+
+struct _McpAccountManagerUoaPrivate
+{
+  McpAccountManager *am;
+
+  AgManager *manager;
+  EmpathyWebcredentialsMonitor *monitor;
+
+  /* alloc'ed string -> ref'ed AgAccountService
+   * The key is the account_name, an MC unique identifier.
+   * Note: There could be multiple services in this table having the same
+   * AgAccount, even if unlikely. */
+  GHashTable *accounts;
+
+  /* Queue of owned DelayedSignalData */
+  GQueue *pending_signals;
+
+  gboolean loaded;
+  gboolean ready;
+};
+
+typedef enum {
+  DELAYED_CREATE,
+  DELAYED_DELETE,
+} DelayedSignal;
+
+typedef struct {
+  DelayedSignal signal;
+  AgAccountId account_id;
+} DelayedSignalData;
+
+
+static gchar *
+_service_dup_tp_value (AgAccountService *service,
+    const gchar *key)
+{
+  gchar *real_key = g_strdup_printf (KEY_PREFIX "%s", key);
+  GVariant *value;
+
+  value = ag_account_service_get_variant (service, real_key, NULL);
+  g_free (real_key);
+  if (value == NULL)
+    return NULL;
+
+  return g_variant_dup_string (value, NULL);
+}
+
+static void
+_service_set_tp_value (AgAccountService *service,
+    const gchar *key,
+    const gchar *value)
+{
+  gchar *real_key = g_strdup_printf (KEY_PREFIX "%s", key);
+
+  if (value != NULL)
+    {
+      GVariant *gvariant = g_variant_new_string (value);
+      ag_account_service_set_variant (service, real_key, gvariant);
+    }
+  else
+    {
+      ag_account_service_set_variant (service, real_key, NULL);
+    }
+  g_free (real_key);
+}
+
+/* Returns NULL if the account never has been imported into MC before */
+static gchar *
+_service_dup_tp_account_name (AgAccountService *service)
+{
+  return _service_dup_tp_value (service, KEY_ACCOUNT_NAME);
+}
+
+static void
+_service_set_tp_account_name (AgAccountService *service,
+    const gchar *account_name)
+{
+  _service_set_tp_value (service, KEY_ACCOUNT_NAME, account_name);
+}
+
+static void
+_service_enabled_cb (AgAccountService *service,
+    gboolean enabled,
+    McpAccountManagerUoa *self)
+{
+  gchar *account_name = _service_dup_tp_account_name (service);
+
+  if (!self->priv->ready || account_name == NULL)
+    return;
+
+  DEBUG ("UOA account %s toggled: %s", account_name,
+      enabled ? "enabled" : "disabled");
+
+  g_signal_emit_by_name (self, "toggled", account_name, enabled);
+
+  g_free (account_name);
+}
+
+static void
+_service_changed_cb (AgAccountService *service,
+    McpAccountManagerUoa *self)
+{
+  gchar *account_name = _service_dup_tp_account_name (service);
+
+  if (!self->priv->ready || account_name == NULL)
+    return;
+
+  DEBUG ("UOA account %s changed", account_name);
+
+  /* FIXME: Could use ag_account_service_get_changed_fields()
+   * and emit "altered-one" */
+  g_signal_emit_by_name (self, "altered", account_name);
+
+  g_free (account_name);
+}
+
+static void
+_account_stored_cb (GObject *source_object,
+    GAsyncResult *res,
+    gpointer user_data)
+{
+  AgAccount *account = AG_ACCOUNT(source_object);
+  GError *error = NULL;
+
+  if (!ag_account_store_finish (account, res, &error))
+    {
+      g_assert (error != NULL);
+      DEBUG ("Error storing UOA account '%s': %s",
+          ag_account_get_display_name (account),
+          error->message);
+      g_error_free (error);
+    }
+}
+
+static gboolean
+_add_service (McpAccountManagerUoa *self,
+    AgAccountService *service,
+    const gchar *account_name)
+{
+  DEBUG ("UOA account %s added", account_name);
+
+  if (g_hash_table_contains (self->priv->accounts, account_name))
+    {
+      DEBUG ("Already exists, ignoring");
+      return FALSE;
+    }
+
+  g_hash_table_insert (self->priv->accounts,
+      g_strdup (account_name),
+      g_object_ref (service));
+
+  g_signal_connect (service, "enabled",
+      G_CALLBACK (_service_enabled_cb), self);
+  g_signal_connect (service, "changed",
+      G_CALLBACK (_service_changed_cb), self);
+
+  return TRUE;
+}
+
+static void
+_account_created_cb (AgManager *manager,
+    AgAccountId id,
+    McpAccountManagerUoa *self)
+{
+  AgAccount *account;
+  GList *l;
+
+  if (!self->priv->ready)
+    {
+      DelayedSignalData *data = g_slice_new0 (DelayedSignalData);
+
+      data->signal = DELAYED_CREATE;
+      data->account_id = id;
+
+      g_queue_push_tail (self->priv->pending_signals, data);
+      return;
+    }
+
+  account = ag_manager_get_account (self->priv->manager, id);
+
+  l = ag_account_list_services_by_type (account, SERVICE_TYPE);
+  while (l != NULL)
+    {
+      AgAccountService *service = ag_account_service_new (account, l->data);
+      gchar *account_name = _service_dup_tp_account_name (service);
+
+      /* If this is the first time we see this service, we have to generate an
+       * account_name for it. */
+      if (account_name == NULL)
+        {
+          gchar *cm_name = NULL;
+          gchar *protocol_name = NULL;
+          gchar *account_param = NULL;
+
+          cm_name = _service_dup_tp_value (service, "manager");
+          protocol_name = _service_dup_tp_value (service, "protocol");
+          account_param = _service_dup_tp_value (service, "param-account");
+
+          if (!tp_str_empty (cm_name) &&
+              !tp_str_empty (protocol_name) &&
+              !tp_str_empty (account_param))
+            {
+              GHashTable *params;
+
+              params = tp_asv_new (
+                  "account", G_TYPE_STRING, account_param,
+                  NULL);
+
+              account_name = mcp_account_manager_get_unique_name (self->priv->am,
+                  cm_name, protocol_name, params);
+              _service_set_tp_account_name (service, account_name);
+
+              ag_account_store_async (account, NULL, _account_stored_cb, self);
+
+              g_hash_table_unref (params);
+            }
+
+          g_free (cm_name);
+          g_free (protocol_name);
+          g_free (account_param);
+        }
+
+      if (account_name != NULL)
+        {
+          if (_add_service (self, service, account_name))
+            g_signal_emit_by_name (self, "created", account_name);
+        }
+
+      g_free (account_name);
+      g_object_unref (service);
+      ag_service_unref (l->data);
+      l = g_list_delete_link (l, l);
+    }
+
+  g_object_unref (account);
+}
+
+static void
+_account_deleted_cb (AgManager *manager,
+    AgAccountId id,
+    McpAccountManagerUoa *self)
+{
+  GHashTableIter iter;
+  gpointer value;
+
+  if (!self->priv->ready)
+    {
+      DelayedSignalData *data = g_slice_new0 (DelayedSignalData);
+
+      data->signal = DELAYED_DELETE;
+      data->account_id = id;
+
+      g_queue_push_tail (self->priv->pending_signals, data);
+      return;
+    }
+
+  g_hash_table_iter_init (&iter, self->priv->accounts);
+  while (g_hash_table_iter_next (&iter, NULL, &value))
+    {
+      AgAccountService *service = value;
+      AgAccount *account = ag_account_service_get_account (service);
+      gchar *account_name;
+
+      if (account->id != id)
+        continue;
+
+      account_name = _service_dup_tp_account_name (service);
+      if (account_name == NULL)
+        continue;
+
+      DEBUG ("UOA account %s deleted", account_name);
+
+      g_hash_table_iter_remove (&iter);
+      g_signal_emit_by_name (self, "deleted", account_name);
+
+      g_free (account_name);
+    }
+}
+
+static void
+mcp_account_manager_uoa_dispose (GObject *object)
+{
+  McpAccountManagerUoa *self = (McpAccountManagerUoa *) object;
+
+  tp_clear_object (&self->priv->am);
+  tp_clear_object (&self->priv->manager);
+  tp_clear_pointer (&self->priv->accounts, g_hash_table_unref);
+  tp_clear_object (&self->priv->monitor);
+
+  G_OBJECT_CLASS (mcp_account_manager_uoa_parent_class)->dispose (object);
+}
+
+static void
+mcp_account_manager_uoa_init (McpAccountManagerUoa *self)
+{
+  DEBUG ("UOA MC plugin initialised");
+
+  self->priv = G_TYPE_INSTANCE_GET_PRIVATE (self,
+      MCP_TYPE_ACCOUNT_MANAGER_UOA, McpAccountManagerUoaPrivate);
+
+  self->priv->accounts = g_hash_table_new_full (g_str_hash, g_str_equal,
+      g_free, g_object_unref);
+  self->priv->pending_signals = g_queue_new ();
+
+  self->priv->manager = ag_manager_new_for_service_type (SERVICE_TYPE);
+  g_return_if_fail (self->priv->manager != NULL);
+
+  g_signal_connect (self->priv->manager, "account-created",
+      G_CALLBACK (_account_created_cb), self);
+  g_signal_connect (self->priv->manager, "account-deleted",
+      G_CALLBACK (_account_deleted_cb), self);
+
+  self->priv->monitor = empathy_webcredentials_monitor_new (
+      self->priv->manager);
+}
+
+static void
+mcp_account_manager_uoa_class_init (McpAccountManagerUoaClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  gobject_class->dispose = mcp_account_manager_uoa_dispose;
+
+  g_type_class_add_private (gobject_class,
+      sizeof (McpAccountManagerUoaPrivate));
+}
+
+static void
+_ensure_loaded (McpAccountManagerUoa *self)
+{
+  GList *services;
+
+  if (self->priv->loaded)
+    return;
+
+  self->priv->loaded = TRUE;
+
+  g_assert (!self->priv->ready);
+
+  services = ag_manager_get_account_services (self->priv->manager);
+  while (services != NULL)
+    {
+      AgAccountService *service = services->data;
+      AgAccount *account = ag_account_service_get_account (service);
+      gchar *account_name = _service_dup_tp_account_name (service);
+
+      if (account_name != NULL)
+        {
+          /* This service was already known, we can add it now */
+          _add_service (self, service, account_name);
+          g_free (account_name);
+        }
+      else
+        {
+          DelayedSignalData *data = g_slice_new0 (DelayedSignalData);
+
+          /* This service was created while MC was not running, delay its
+           * creation until MC is ready */
+          data->signal = DELAYED_CREATE;
+          data->account_id = account->id;
+
+          g_queue_push_tail (self->priv->pending_signals, data);
+        }
+
+      g_object_unref (services->data);
+      services = g_list_delete_link (services, services);
+    }
+}
+
+static GList *
+account_manager_uoa_list (const McpAccountStorage *storage,
+    const McpAccountManager *am)
+{
+  McpAccountManagerUoa *self = (McpAccountManagerUoa *) storage;
+  GList *accounts = NULL;
+  GHashTableIter iter;
+  gpointer key;
+
+  DEBUG (G_STRFUNC);
+
+  g_return_val_if_fail (self->priv->manager != NULL, NULL);
+
+  _ensure_loaded (self);
+
+  g_hash_table_iter_init (&iter, self->priv->accounts);
+  while (g_hash_table_iter_next (&iter, &key, NULL))
+    accounts = g_list_prepend (accounts, g_strdup (key));
+
+  return accounts;
+}
+
+static const gchar *
+provider_to_tp_service_name (const gchar *provider_name)
+{
+  /* Well known services are defined in Telepathy spec:
+   * http://telepathy.freedesktop.org/spec/Account.html#Property:Service */
+  if (!tp_strdiff (provider_name, "google"))
+    return "google-talk";
+
+  return provider_name;
+}
+
+static gboolean
+account_manager_uoa_get (const McpAccountStorage *storage,
+    const McpAccountManager *am,
+    const gchar *account_name,
+    const gchar *key)
+{
+  McpAccountManagerUoa *self = (McpAccountManagerUoa *) storage;
+  AgAccountService *service;
+  AgAccount *account;
+  AgService *s;
+  gboolean handled = FALSE;
+
+  g_return_val_if_fail (self->priv->manager != NULL, FALSE);
+
+  service = g_hash_table_lookup (self->priv->accounts, account_name);
+  if (service == NULL)
+    return FALSE;
+
+  DEBUG ("%s: %s, %s", G_STRFUNC, account_name, key);
+
+  account = ag_account_service_get_account (service);
+  s = ag_account_service_get_service (service);
+
+  /* NULL key means we want all settings */
+  if (key == NULL)
+    {
+      AgAccountSettingIter iter;
+      const gchar *k;
+      GVariant *v;
+
+      ag_account_service_settings_iter_init (service, &iter, KEY_PREFIX);
+      while (ag_account_settings_iter_get_next (&iter, &k, &v))
+        {
+          if (!g_variant_is_of_type (v, G_VARIANT_TYPE_STRING))
+            continue;
+
+          mcp_account_manager_set_value (am, account_name,
+              k, g_variant_get_string (v, NULL));
+        }
+    }
+
+  /* Some special keys that are not stored in setting */
+  if (key == NULL || !tp_strdiff (key, "Enabled"))
+    {
+      mcp_account_manager_set_value (am, account_name, "Enabled",
+          ag_account_service_get_enabled (service) ? "true" : "false");
+      handled = TRUE;
+    }
+
+  if (key == NULL || !tp_strdiff (key, "DisplayName"))
+    {
+      mcp_account_manager_set_value (am, account_name, "DisplayName",
+          ag_account_get_display_name (account));
+      handled = TRUE;
+    }
+
+  if (key == NULL || !tp_strdiff (key, "Service"))
+    {
+      mcp_account_manager_set_value (am, account_name, "Service",
+          provider_to_tp_service_name (ag_account_get_provider_name (account)));
+      handled = TRUE;
+    }
+
+  if (key == NULL || !tp_strdiff (key, "Icon"))
+    {
+      mcp_account_manager_set_value (am, account_name, "Icon",
+          ag_service_get_icon_name (s));
+      handled = TRUE;
+    }
+
+  /* If it was none of the above, then just lookup in service' settings */
+  if (!handled)
+    {
+      gchar *value = _service_dup_tp_value (service, key);
+
+      mcp_account_manager_set_value (am, account_name, key, value);
+      g_free (value);
+    }
+
+  return TRUE;
+}
+
+static gboolean
+account_manager_uoa_set (const McpAccountStorage *storage,
+    const McpAccountManager *am,
+    const gchar *account_name,
+    const gchar *key,
+    const gchar *val)
+{
+  McpAccountManagerUoa *self = (McpAccountManagerUoa *) storage;
+  AgAccountService *service;
+  AgAccount *account;
+
+  g_return_val_if_fail (self->priv->manager != NULL, FALSE);
+
+  service = g_hash_table_lookup (self->priv->accounts, account_name);
+  if (service == NULL)
+    return FALSE;
+
+  account = ag_account_service_get_account (service);
+
+  DEBUG ("%s: %s, %s, %s", G_STRFUNC, account_name, key, val);
+
+  if (!tp_strdiff (key, "Enabled"))
+    {
+      /* Enabled is a global setting on the account, not per-services,
+       * unfortunately */
+      ag_account_select_service (account, NULL);
+      ag_account_set_enabled (account, !tp_strdiff (val, "true"));
+    }
+  else if (!tp_strdiff (key, "DisplayName"))
+    {
+      ag_account_set_display_name (account, val);
+    }
+  else
+    {
+      _service_set_tp_value (service, key, val);
+    }
+
+  return TRUE;
+}
+
+static gchar *
+account_manager_uoa_create (const McpAccountStorage *storage,
+    const McpAccountManager *am,
+    const gchar *cm_name,
+    const gchar *protocol_name,
+    GHashTable *params,
+    GError **error)
+{
+  McpAccountManagerUoa *self = (McpAccountManagerUoa *) storage;
+  gchar *account_name;
+  AgAccount *account;
+  AgAccountService *service;
+  GList *l;
+
+  g_return_val_if_fail (self->priv->manager != NULL, NULL);
+
+  if (!self->priv->ready)
+    {
+      g_set_error (error, TP_ERROR, TP_ERROR_INVALID_ARGUMENT,
+          "Cannot create account before being ready");
+      return NULL;
+    }
+
+  DEBUG (G_STRFUNC);
+
+  /* Create a new AgAccountService and keep it internally. This won't save it
+   * into persistent storage until account_manager_uoa_commit() is called.
+   * We assume there is only one IM service */
+  account = ag_manager_create_account (self->priv->manager, protocol_name);
+  l = ag_account_list_services_by_type (account, SERVICE_TYPE);
+  if (l == NULL)
+    {
+      g_set_error (error, TP_ERROR, TP_ERROR_INVALID_ARGUMENT,
+          "Cannot create a %s service for %s provider",
+          SERVICE_TYPE, protocol_name);
+      g_object_unref (account);
+      return NULL;
+    }
+  service = ag_account_service_new (account, l->data);
+  ag_service_list_free (l);
+  g_object_unref (account);
+
+  account_name = mcp_account_manager_get_unique_name (self->priv->am,
+      cm_name, protocol_name, params);
+  _service_set_tp_account_name (service, account_name);
+  g_assert (_add_service (self, service, account_name));
+
+  /* MC will set all params on the account and commit */
+
+  return account_name;
+}
+
+static gboolean
+account_manager_uoa_delete (const McpAccountStorage *storage,
+    const McpAccountManager *am,
+    const gchar *account_name,
+    const gchar *key)
+{
+  McpAccountManagerUoa *self = (McpAccountManagerUoa *) storage;
+  AgAccountService *service;
+  AgAccount *account;
+
+  g_return_val_if_fail (self->priv->manager != NULL, FALSE);
+
+  service = g_hash_table_lookup (self->priv->accounts, account_name);
+  if (service == NULL)
+    return FALSE;
+
+  account = ag_account_service_get_account (service);
+
+  DEBUG ("%s: %s, %s", G_STRFUNC, account_name, key);
+
+  if (key == NULL)
+    {
+      ag_account_delete (account);
+      g_hash_table_remove (self->priv->accounts, account_name);
+    }
+  else
+    {
+      _service_set_tp_value (service, key, NULL);
+    }
+
+  return TRUE;
+}
+
+static gboolean
+account_manager_uoa_commit (const McpAccountStorage *storage,
+    const McpAccountManager *am)
+{
+  McpAccountManagerUoa *self = (McpAccountManagerUoa *) storage;
+  GHashTableIter iter;
+  gpointer value;
+
+  DEBUG (G_STRFUNC);
+
+  g_return_val_if_fail (self->priv->manager != NULL, FALSE);
+
+  g_hash_table_iter_init (&iter, self->priv->accounts);
+  while (g_hash_table_iter_next (&iter, NULL, &value))
+    {
+      AgAccountService *service = value;
+      AgAccount *account = ag_account_service_get_account (service);
+
+      ag_account_store_async (account, NULL, _account_stored_cb, self);
+    }
+
+  return TRUE;
+}
+
+static void
+failure_removed_cb (EmpathyWebcredentialsMonitor *monitor,
+    AgAccount *account,
+    McpAccountManagerUoa *self)
+{
+  GList *l;
+
+  DEBUG ("Account '%u' is not failing any more", account->id);
+
+  l = ag_account_list_services_by_type (account, SERVICE_TYPE);
+  while (l != NULL)
+    {
+      AgAccountService *service = ag_account_service_new (account, l->data);
+      gchar *account_name = _service_dup_tp_account_name (service);
+
+      if (account_name != NULL)
+        {
+          DEBUG ("Reconnect account %s", account_name);
+
+          mcp_account_storage_emit_reconnect (MCP_ACCOUNT_STORAGE (self),
+              account_name);
+        }
+
+      g_free (account_name);
+      g_object_unref (service);
+      ag_service_unref (l->data);
+      l = g_list_delete_link (l, l);
+    }
+}
+
+static void
+account_manager_uoa_ready (const McpAccountStorage *storage,
+    const McpAccountManager *am)
+{
+  McpAccountManagerUoa *self = (McpAccountManagerUoa *) storage;
+  DelayedSignalData *data;
+
+  g_return_if_fail (self->priv->manager != NULL);
+
+  if (self->priv->ready)
+    return;
+
+  DEBUG (G_STRFUNC);
+
+  self->priv->ready = TRUE;
+  self->priv->am = g_object_ref (G_OBJECT (am));
+
+  while ((data = g_queue_pop_head (self->priv->pending_signals)) != NULL)
+    {
+      switch (data->signal)
+        {
+          case DELAYED_CREATE:
+            _account_created_cb (self->priv->manager, data->account_id, self);
+            break;
+          case DELAYED_DELETE:
+            _account_deleted_cb (self->priv->manager, data->account_id, self);
+            break;
+          default:
+            g_assert_not_reached ();
+        }
+
+      g_slice_free (DelayedSignalData, data);
+    }
+
+  g_queue_free (self->priv->pending_signals);
+  self->priv->pending_signals = NULL;
+
+  g_signal_connect (self->priv->monitor, "failure-removed",
+      G_CALLBACK (failure_removed_cb), self);
+}
+
+static void
+account_manager_uoa_get_identifier (const McpAccountStorage *storage,
+    const gchar *account_name,
+    GValue *identifier)
+{
+  McpAccountManagerUoa *self = (McpAccountManagerUoa *) storage;
+  AgAccountService *service;
+  AgAccount *account;
+
+  g_return_if_fail (self->priv->manager != NULL);
+
+  service = g_hash_table_lookup (self->priv->accounts, account_name);
+  if (service == NULL)
+    return;
+
+  account = ag_account_service_get_account (service);
+
+  g_value_init (identifier, G_TYPE_UINT);
+  g_value_set_uint (identifier, account->id);
+}
+
+static guint
+account_manager_uoa_get_restrictions (const McpAccountStorage *storage,
+    const gchar *account_name)
+{
+  McpAccountManagerUoa *self = (McpAccountManagerUoa *) storage;
+  AgAccountService *service;
+  guint restrictions = TP_STORAGE_RESTRICTION_FLAG_CANNOT_SET_SERVICE;
+  GVariant *value;
+
+  g_return_val_if_fail (self->priv->manager != NULL, 0);
+
+  /* If we don't know this account, we cannot do anything */
+  service = g_hash_table_lookup (self->priv->accounts, account_name);
+  if (service == NULL)
+    return G_MAXUINT;
+
+  value = ag_account_service_get_variant (service,
+      KEY_PREFIX KEY_READONLY_PARAMS, NULL);
+
+  if (value != NULL && g_variant_get_boolean (value))
+    restrictions |= TP_STORAGE_RESTRICTION_FLAG_CANNOT_SET_PARAMETERS;
+
+  /* FIXME: We can't set Icon either, but there is no flag for that */
+  return restrictions;
+}
+
+static void
+account_storage_iface_init (McpAccountStorageIface *iface)
+{
+  iface->name = PLUGIN_NAME;
+  iface->desc = PLUGIN_DESCRIPTION;
+  iface->priority = PLUGIN_PRIORITY;
+  iface->provider = PLUGIN_PROVIDER;
+
+  iface->get = account_manager_uoa_get;
+  iface->list = account_manager_uoa_list;
+  iface->set = account_manager_uoa_set;
+  iface->create = account_manager_uoa_create;
+  iface->delete = account_manager_uoa_delete;
+  iface->commit = account_manager_uoa_commit;
+  iface->ready = account_manager_uoa_ready;
+  iface->get_identifier = account_manager_uoa_get_identifier;
+  iface->get_restrictions = account_manager_uoa_get_restrictions;
+}
+
+McpAccountManagerUoa *
+mcp_account_manager_uoa_new (void)
+{
+  return g_object_new (MCP_TYPE_ACCOUNT_MANAGER_UOA, NULL);
+}
diff --git a/plugins/mcp-account-manager-uoa.h b/plugins/mcp-account-manager-uoa.h
new file mode 100644
index 0000000..d5793e1
--- /dev/null
+++ b/plugins/mcp-account-manager-uoa.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright © 2012 Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <mission-control-plugins/mission-control-plugins.h>
+
+#ifndef __MCP_ACCOUNT_MANAGER_UOA_H__
+#define __MCP_ACCOUNT_MANAGER_UOA_H__
+
+G_BEGIN_DECLS
+
+#define EMPATHY_UOA_PROVIDER "im.telepathy.Account.Storage.UOA"
+
+#define MCP_TYPE_ACCOUNT_MANAGER_UOA \
+  (mcp_account_manager_uoa_get_type ())
+
+#define MCP_ACCOUNT_MANAGER_UOA(o) \
+  (G_TYPE_CHECK_INSTANCE_CAST ((o), MCP_TYPE_ACCOUNT_MANAGER_UOA,   \
+      McpAccountManagerUoa))
+
+#define MCP_ACCOUNT_MANAGER_UOA_CLASS(k)     \
+    (G_TYPE_CHECK_CLASS_CAST((k), MCP_TYPE_ACCOUNT_MANAGER_UOA, \
+        McpAccountManagerUoaClass))
+
+#define MCP_IS_ACCOUNT_MANAGER_UOA(o) \
+  (G_TYPE_CHECK_INSTANCE_TYPE ((o), MCP_TYPE_ACCOUNT_MANAGER_UOA))
+
+#define MCP_IS_ACCOUNT_MANAGER_UOA_CLASS(k)  \
+  (G_TYPE_CHECK_CLASS_TYPE ((k), MCP_TYPE_ACCOUNT_MANAGER_UOA))
+
+#define MCP_ACCOUNT_MANAGER_UOA_GET_CLASS(o) \
+    (G_TYPE_INSTANCE_GET_CLASS ((o), MCP_TYPE_ACCOUNT_MANAGER_UOA, \
+        McpAccountManagerUoaClass))
+
+typedef struct _McpAccountManagerUoaPrivate McpAccountManagerUoaPrivate;
+
+typedef struct {
+  GObject parent;
+
+  McpAccountManagerUoaPrivate *priv;
+} _McpAccountManagerUoa;
+
+typedef struct {
+  GObjectClass parent_class;
+} _McpAccountManagerUoaClass;
+
+typedef _McpAccountManagerUoa McpAccountManagerUoa;
+typedef _McpAccountManagerUoaClass McpAccountManagerUoaClass;
+
+GType mcp_account_manager_uoa_get_type (void) G_GNUC_CONST;
+
+McpAccountManagerUoa *mcp_account_manager_uoa_new (void);
+
+G_END_DECLS
+
+#endif
diff --git a/plugins/mission-control-plugin.c b/plugins/mission-control-plugin.c
new file mode 100644
index 0000000..d7a33fd
--- /dev/null
+++ b/plugins/mission-control-plugin.c
@@ -0,0 +1,47 @@
+/*
+ * mission-control-plugin.c
+ *
+ * A Mission Control plugin to expose Ubuntu Online Accounts with chat
+ * capabilities (e.g. Facebook) to Mission Control
+ *
+ * Copyright (C) 2012 Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Authors: Xavier Claessens <xavier.claessens@collabora.co.uk>
+ */
+
+#include <mission-control-plugins/mission-control-plugins.h>
+
+#include "mcp-account-manager-uoa.h"
+
+GObject *
+mcp_plugin_ref_nth_object (guint n)
+{
+  static void *plugin_0 = NULL;
+
+  switch (n)
+    {
+      case 0:
+        if (plugin_0 == NULL)
+          plugin_0 = g_object_new (MCP_TYPE_ACCOUNT_MANAGER_UOA, NULL);
+        else
+          g_object_ref (plugin_0);
+
+        return plugin_0;
+
+      default:
+        return NULL;
+    }
+}
diff --git a/src/Makefile.am b/src/Makefile.am
index 4d679cd..c728e64 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -34,18 +34,18 @@ mc_headers = \
 	mcd-transport.h \
 	mcd-storage.h
 
-if ENABLE_LIBACCOUNTS_SSO
-mc_headers += \
-	mcd-account-manager-sso.h \
-	$(NULL)
-
-if ENABLE_LIBACCOUNTS_GLIB_HIDDEN
-mc_headers += \
-	mcd-storage-ag-hidden.h \
-	$(NULL)
-endif
-
-endif
+# if ENABLE_LIBACCOUNTS_SSO
+# mc_headers += \
+# 	mcd-account-manager-sso.h \
+# 	$(NULL)
+#
+# if ENABLE_LIBACCOUNTS_GLIB_HIDDEN
+# mc_headers += \
+# 	mcd-storage-ag-hidden.h \
+# 	$(NULL)
+# endif
+#
+# endif
 
 mc_gen_headers = \
 	_gen/cli-Connection_Manager_Interface_Account_Storage.h \
@@ -105,10 +105,10 @@ if ENABLE_GNOME_KEYRING
 libmcd_convenience_la_LIBADD += $(GNOME_KEYRING_LIBS)
 endif
 
-if ENABLE_LIBACCOUNTS_SSO
-libmcd_convenience_la_LIBADD += $(LIBACCOUNTS_SSO_LIBS)
-INCLUDES += $(LIBACCOUNTS_SSO_CFLAGS)
-endif
+# if ENABLE_LIBACCOUNTS_SSO
+# libmcd_convenience_la_LIBADD += $(LIBACCOUNTS_SSO_LIBS)
+# INCLUDES += $(LIBACCOUNTS_SSO_CFLAGS)
+# endif
 
 if ENABLE_AEGIS
 libmcd_convenience_la_LIBADD += $(top_builddir)/plugins/libmcp-aegis.la
@@ -179,18 +179,18 @@ libmcd_convenience_la_SOURCES = \
 	sp_timestamp.h \
 	$(mc_headers)
 
-if ENABLE_LIBACCOUNTS_SSO
-libmcd_convenience_la_SOURCES += \
-	mcd-account-manager-sso.c \
-	$(NULL)
-
-if ENABLE_LIBACCOUNTS_GLIB_HIDDEN
-libmcd_convenience_la_SOURCES += \
-	mcd-storage-ag-hidden.c \
-	$(NULL)
-endif
-
-endif
+# if ENABLE_LIBACCOUNTS_SSO
+# libmcd_convenience_la_SOURCES += \
+# 	mcd-account-manager-sso.c \
+# 	$(NULL)
+#
+# if ENABLE_LIBACCOUNTS_GLIB_HIDDEN
+# libmcd_convenience_la_SOURCES += \
+# 	mcd-storage-ag-hidden.c \
+# 	$(NULL)
+# endif
+#
+# endif
 
 mcd-enum-types.h: stamp-mcd-enum-types.h
 	$(AM_V_GEN)true
diff --git a/tests/Makefile.am b/tests/Makefile.am
index c02550f..2c3f508 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -55,8 +55,8 @@ keyring_command_LDADD = $(GLIB_LIBS) $(GNOME_KEYRING_LIBS)
 keyring_command_SOURCES = keyring-command.c
 endif
 
-if ENABLE_LIBACCOUNTS_SSO
-account_store_SOURCES += account-store-libaccounts.c account-store-libaccounts.h
-account_store_LDADD += $(LIBACCOUNTS_SSO_LIBS)
-INCLUDES += $(LIBACCOUNTS_SSO_CFLAGS)
-endif
+# if ENABLE_LIBACCOUNTS_SSO
+# account_store_SOURCES += account-store-libaccounts.c account-store-libaccounts.h
+# account_store_LDADD += $(LIBACCOUNTS_SSO_LIBS)
+# INCLUDES += $(LIBACCOUNTS_SSO_CFLAGS)
+# endif
diff --git a/tests/twisted/Makefile.am b/tests/twisted/Makefile.am
index 7542e46..998d236 100644
--- a/tests/twisted/Makefile.am
+++ b/tests/twisted/Makefile.am
@@ -245,11 +245,11 @@ if ENABLE_GNOME_KEYRING
 BASIC_TESTS_ENVIRONMENT += MC_TEST_GNOME_KEYRING=1
 endif
 
-if ENABLE_LIBACCOUNTS_SSO
-BASIC_TESTS_ENVIRONMENT += AG_DEBUG=all \
-	ACCOUNTS=@abs_top_builddir@/tests/twisted/tmp-$(TMPSUFFIX) \
-	AG_SERVICES=@abs_top_builddir@/tests/twisted/tmp-$(TMPSUFFIX)
-endif
+# if ENABLE_LIBACCOUNTS_SSO
+# BASIC_TESTS_ENVIRONMENT += AG_DEBUG=all \
+# 	ACCOUNTS=@abs_top_builddir@/tests/twisted/tmp-$(TMPSUFFIX) \
+# 	AG_SERVICES=@abs_top_builddir@/tests/twisted/tmp-$(TMPSUFFIX)
+# endif
 
 WITH_SESSION_BUS = \
 	sh $(srcdir)/tools/with-session-bus.sh \
